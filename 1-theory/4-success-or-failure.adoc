= Success or Failure

Dealing with the Happy Path™ in an API is pretty easy: When a client asks for a
resource, show them the resource. When they trigger a procedure, let them know
if it was triggered ok, and maybe if it completed without a problem.

What to do when something doesn't go according to plan? Well, that can be
tricky.

== Errors

HTTP status codes are part of the picture, they can define a category of issue,
but they are never going to explain the whole story.

[source,text]
----
HTTP/1.1 400 Bad Request

{
  "errors" : [{
    "code"   : 20002,
    "title"  : "There are no savings for this user."
  }]
}
----

[source,text]
----
HTTP/1.1 400 Bad Request

{
  "errors" : [{
    "code"   : 20010,
    "title"  : "Invalid geopoints for simulated savings."
  }]
}
----


This is often touted as a failing of the HTTP status code concept, but it was
never intended to cover every single possible application specific error
message. Think of HTTP status codes like an exception. In Ruby you might get a
`ArgumentError` or `LoadError` exception which gives you a pretty good hint as
to what the issue is, but there is also data specific to the instance of that
failure that helps with fixing the situation.

.Programming languages do not just give you the exception name, they give you instance information too.
[source,ruby]
----
> require "nonsense"
LoadError (cannot load such file -- nonsense)
----

Errors in HTTP APIs are pretty similar to exceptions: they can tell the client
what is going on, and combine a bunch of useful metadata to help both the client
and the server solve problems. This is often in the response body, using JSON or
whatever data format the API generally uses.

=== Error Objects

A well designed API error will have at the very least:

- A 4xx or 5xx status code depending on the situation
- A human readable short summary: `Cannot checkout with an empty shopping cart`
- A human readable message: `It looks like you have tried to check out but there is nothing in your...`
- An application-specific error code relating to the problem: `ERRCARTEMPTY`
- Links to a documentation page or knowledge based where a client or user of the client can figure out what to do next

This will help humans and machines to figure out what is happening. Missing out
the error code means clients need to implement substring matching, which is
awful for everyone, and turns contents of the error message into part of the
agree contract. Imagine a text-change breaking integration with multiple unknown
clients! 😳

This used to happen with Facebook and their rather bad Graph API, where any issue
with an access token would return type: `OAuthException`, regardless of the type
of issue. If it was an expired token which needed a refresh, or if it was just
total nonsense, you would get the same type, and a different string.

[source,javascript]
----
{
  "error": {
    "type": "OAuthException",
    "message": "Session has expired at unix time 1385243766.
The current unix time is 1385848532."
  }
}
----

Without getting too much into Authentication at this point, there are times
where the client would want to take different actions for different errors. For
example, when an access token was previously good but expires, the client wants
to suggest the user try logging in again, or reconnecting their Facebook
account. When the token is just nonsense (a totally invalid token) then a
different action needs to be taken.

These days Facebook have a far more robust error object in their Graph API, with
error codes and even "sub-codes", so the client developer has enough information to
react programmatically to various errors.

.An improved version of that error message, with an error code and a link
[source,javascript]
----
{
  "error": {
    "message": "Message describing the error",
    "type": "OAuthException",
    "code": 190,
    "error_subcode": 460,
    "error_user_title": "A title",
    "error_user_msg": "A message",
    "fbtrace_id": "EJplcsCHuLu"
  }
}
----

They explain the structure of the error object in their documentation.

[quote,Facebook GraphAPI Documentation,https://developers.facebook.com/docs/graph-api/using-graph-api/error-handling]
____
- *message:* A human-readable description of the error.
- *code:* An error code. Common values are listed below, along with common recovery tactics.
- *error_subcode:* Additional information about the error. Common values are listed below.
- *error_user_msg:* The message to display to the user. The language of the message is based on the locale of the API request.
- *error_user_title:* The title of the dialog, if shown. The language of the message is based on the locale of the API request.
- *fbtrace_id:* Internal support identifier. When reporting a bug related to a Graph API call, include the fbtrace_id to help us find log data for debugging.
____

=== Know Your Audience

Making errors be useful for client users (not just client developers) can be a
powerful thing. Clients can build their interface around the expectation that a link in an error
will help their users out, without needing to know specifically what the actual
error is.

Whenever possible try to avoid creating an API error that you would not want to
show to a user. Often a client will create a filter that checks for certain
errors to do something, and anything left can be thrown up as a generic error
box with the message in it.

Client doing this helps future proof their application. For example, if a new
validation rules pops up they might not have their UI code written to check for
that, but an ugly alert box can pop up with instructions to the user and maybe
that is better than the application just being completely unusable.

Another useful thing to do is put a link for more information.

.Add a href/link/url property to your error object.
[source,javascript]
----
{
  "error": {
    ....
    "href": "http://example.org/docs/errors/#ERR-01234"
  }
}
----

In some instances maybe this more information link points to a blog post or some documentation which
explains that the user should update their application, or take some other action to resolve the situation, or email somebody, or reset their password. 👍

// TODO show how to create error codes with logical ranges and grouping and potentially locale based thing too

=== The Trouble with Custom Error Formats

Everyone starts off building APIs with their own error format. It usually starts
off as just a string.

[source,javascript]
----
{
  "error": "A thing went really wrong"
}
----

Then somebody points out if would be nice to have application codes, and new
versions of the API (or some different APIs built in the same architecture)
start using a slightly modified format.

[source,javascript]
----
{
  "error": {
    "code": "100110",
    "message": "A thing went really wrong"
  }
}
----

Guess what happens when a client is expecting the first example of a single
string, but ends up getting that second example of an object?

.A wild [object Object] appears on Gelato - a discontinued API design and analytics platform acquimerged into Kong.
image::images/errors-object.jpg[An alert box showing the JavaScript to string representation of an object, instead of the error message.]

These errors happened at WeWork all the time, because every API had a totally different error format. I remember writing a bunch of code that would check for various properties, if error is a string, if error is an object, if error is an object containing foo, if error is an object containing bar....

=== Standard Error Formats

There are two common standards out there for API errors which you should
consider using for your next API, or maybe even consider adding to your existing
APIs.

==== Problem Details for HTTP APIs

https://tools.ietf.org/html/rfc7807[RFC 7807] is a brilliant standard from Mark
Nottingham, Eric Wilde, and Akamai, released through the IETF.

[quote,Internet Engineering Task Force (IETF),https://tools.ietf.org/html/rfc7807]
This document defines a "problem detail" as a way to carry machine- readable
details of errors in a HTTP response to avoid the need to define new error
response formats for HTTP APIs.

The goal of this RFC is to give a standard structure for errors in HTTP APIs
that use JSON (`application/problem+json`) or XML (`application/problem+xml`).

The standard was only released as a final RCC in 2016 and as such there are not
many popular APIs using it yet. This is part of a common stalemate problem where
people do not implement until large companies do, and as such they just roll
their own solutions, making the standard less popular, so the large companies do
not bother to support it.

Many large companies are able to enforce standards, and have enough people
around with enough experience to avoid a lot of the common problems around, but
smaller teams should defer to standards to help them out. If you are Facebook
then certainly roll your own error format, but if you are not then RFC 7807 will
point you in the right direction, and implementations make it easy.

* [crell/api-problem] for PHP

[crell/api-problem]: https://github.com/Crell/ApiProblem

==== JSON:API

[JSON:API](http://jsonapi.org/format/#errors) is discussed in a few sections of this book and is a
standard outlining the general format of requests and responses in JSON when working with HTTP APIs. It
has a section on errors, which I quite like.

The following is an excerpt from the JSON:API standard at time of writing.

> An error object MAY have the following members:

>  * `"id"` - A unique identifier for this particular occurrence of the problem.
>  * `"href"` - A URI that MAY yield further details about this particular occurrence of the problem.
>  * `"status"` - The HTTP status code applicable to this problem, expressed as a string value.
>  * `"code"` - An application-specific error code, expressed as a string value.
>  * `"title"` - A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
>  * `"detail"` - A human-readable explanation specific to this occurrence of the problem.
>  * `"links"` - Associated resources, which can be dereferenced from the request document.
>  * `"path"` - The relative path to the relevant attribute within the associated resource(s). Only appropriate for problems that apply to a single resource or type of resource.

> Additional members MAY be specified within error objects.

// TODO everything below here aint done


=== Validation

Some folks want to treat errors and validation like two different things, but
really a validation message is a validation error, so just an error. There is no
need to try and differentiate between the two.

If a client is trying to create a resource and it is not created, then it is an
error. It really does not matter to the client much if that happened because a
plane landing on the data center, or the date being entered in an unsupported
format, they want to see errors come back. They know if its a server error or
client error based on the HTTP status, and they know if it can be retried or
not, and those are the only differentiations that matter to the client.

If you as an API developer are luck enough to have OpenAPI or JSON Schema
contract files already written up, you can make the art of validation incredibly easy,
and avoid writing a bunch of code to handle the validation rules, just by implementing an
OpenAPI/JSON Schema validator in your controllers, or as middleware.

These validation tools can often be convinced to speak in one of the two common standard error formats, or you can create your own snowflake error format.

== Common Pitfalls

=== 200 OK and Error Code

If you return an HTTP status code of 200 with an error code, then Chuck Norris will roundhouse your door in, destroy your computer, instantly 35-pass wipe your backups, cancel your Dropbox account, and block you from GitHub. HTTP 4xx or 5xx codes alert the client that something bad happened, and error codes provide specifics of the exact issue if the client is interested.

.The folks over at CommitStrip.com know what's up.
image::images/errors-200-ok.jpeg[This monster has got his API responding with HTTP Status 200 OK despite the request failing.]



=== Non-Existent, Gone, or Hiding?

404 is drastically overused in APIs. People use it for "never existed", "no longer exists", "you can't view it" and "it is deactivated", which is way too vague. That can be split up into 404, 403 and 410 but this is still vague.

If you get a 403, this could be because the requesting user is not in the correct group to see the requested content. Should the client suggest you upgrade your account somehow? Are you not friends with the user whose content you are trying to view? Should the client suggest you add them as a friend?

A 410 on a resource could be due to a user deleting that entire piece of content, or it could be down to the user deleting their entire account.

In all of these situations, the ideal solution is to complement the HTTP status code with an error code, which can be whatever you want as long as they are unique within your API and documented somewhere.

Do not do what Google does — supply a list of error codes while having other error codes that are not documented _anywhere_ — because if I see that, I will come for you.


== GraphQL

[source,javascript]
----
{
  "data": {
    "repository": null
  },
  "errors": [
    {
      "type": "NOT_FOUND",
      "path": [
        "repository"
      ],
      "locations": [
        {
          "line": 7,
          "column": 3
        }
      ],
      "message": "Could not resolve to a Repository with the name 'any'."
    }
  ]
}
----