= Success or Failure

== Introduction

// TODO talk about if 434 is not understood it should be handled as 400, etc.
// TODO talk about why standars are important, fucking { error: { message: } = object Object}

Error codes are usually strings or integers that act as a unique index to a corresponding human-readable error message with more information about what is going wrong. That sounds a lot like HTTP status codes, but these errors are about application specific things that may or may not have anything to do with HTTP specific responses.

Some folks will try to use HTTP status codes exclusively and skip using error codes because they do not like the idea of making their own error codes or having to document them, but this is not a scalable approach. There will be some situations where the same endpoint could easily return the same status code for more than one different condition. The status codes are there to merely hint at the category of error relying on the actual error code and error message provided in the HTTP response to include more information in case the client is interested.

For example, an issue with the access token will always result in the user not being recognized. An uninterested client would simply say "User could not get in" while a more interested client would probably prefer to offer suggestions via messages in their own webapp/iPhone app interface.

~~~~~~~~
{
  "error": {
    "type": "OAuthException",
    "message": "Session has expired at unix time 1385243766.
The current unix time is 1385848532."
  }
}
~~~~~~~~

Humans can understand that nicely enough, but Facebook used to lack error codes, making it rather hard for computers to understand the problem. They have added them since the first edition of this book, but before that you would find yourself doing substring matching on the message text, which is lunacy.

Foursquare is not a bad example of using both, but they place an emphasis on tying their errors to a status code.

<https://developer.foursquare.com/overview/responses>

 Twitter does a great job of having HTTP status codes documented and having specific error codes for other issues too. Some are tied to HTTP status codes, which is fine, but many are not. Some are also tied to the same status code, highlighting the issues raised above.

 <https://dev.twitter.com/docs/error-codes-responses>

|Code | Text                                              | Description                                                |
|-----|---------------------------------------------------|------------------------------------------------------------|
|161  | You are unable to follow more people at this time | Corresponds with HTTP 403 - thrown when a user cannot follow another user due to some kind of limit |
|179  | Sorry, you are not authorized to see this status  | Corresponds with HTTP 403 - thrown when a Tweet cannot be viewed by the authenticating user, usually due to the tweet's author having protected their tweets. |

### Programmatically Detecting Error Codes

You can use error codes to make an application respond intelligently to failure of something as basic as a posted Twitter
status.

{title="Using Python to catch exceptions and react to the Twitter error code", lang=python}
~~~~~~~~
try:
    api.PostUpdates(body['text'])

except twitter.TwitterError, exc:

    skip_codes = [
        # Page does not exist
        34,

        # You cannot send messages to users who are not following you
        150,

        # Sent too many
        # TODO Make this requeue with a dekal somehow
        151
    ]

    error_code = exc.__getitem__(0)[0]['code']

    # If the error code is one of those listed before, letâ€™s just end here
    if error_code in skip_codes:
        message.reject()

    else:
        # Rate limit exceeded? Might be worth taking a nap before we requeue
        if error_code == 88:
            time.sleep(10)

        message.requeue()
~~~~~~~~

Compare this sort of logic with the Facebook example from when they lacked error codes:

{title="Using Python to analyse Facebook error strings as no codes exist", lang=python}
~~~~~~~~
except facebook.GraphAPIError, e:

    phrases = ['expired', 'session has been invalidated']

    for phrase in phrases:

        # If the token has expired then lets knock it out so we don't try again
        if e.message.find(phrase) > 0:
            log.info("Deactivating Token %s", user['token_id'])
            self._deactivate_token(user['token_id'])

    log.error("-- Unknown Facebook Error", exec_info=True)
~~~~~~~~

If they change their error messages then this might stop working, which would be a problem. Codes that
do not change are a much more sensible way to go about this.

{title="If Facebook added codes and documentation links to GraphAPI error responses.", lang=json}
~~~~~~~~
{
  "error": {
    "type": "OAuthException",
    "code": "ERR-01234",
    "message": "Session has expired at unix time 1385243766. The current unix time is 1385848532."
    "href": "http://example.org/docs/errors/#ERR-01234"
  }
}
~~~~~~~~

## Error or Errors

When returning errors, I always used to return just one error. In the case of validation I would return
them one at a time as an easy way to exit out of a controller. Thinking about it this was probably just
laziness.

After being forced to work with the JSON-API standard, the use of multiple errors started to feel more natural.

{title="If Facebook returned multiple errors in a list for GraphAPI responses.", lang=json}
~~~~~~~~
{
  "errors": [{
    "type": "OAuthException",
    "code": "ERR-01234",
    "message": "Session has expired at unix time 1385243766. The current unix time is 1385848532."
    "href": "http://example.org/docs/errors/#ERR-01234"
  }]
}
~~~~~~~~

## Standards for Error Responses

So far, this chapter has used entirely home-grown formats for errors. It is incredibly common, even with
the most popular APIs to build completely arbitrary error formats, so I wanted to teach you the theory
before forcing you to read complicated standards.

There are two popular standards that cover error reporting, which are both fairly similar, but sadly
still in draft at time of writing.

### JSON-API

[JSON-API](http://jsonapi.org/format/#errors) is discussed in a few sections of this book and is a
standard outlining the general format of requests and responses in JSON when working with HTTP APIs. It
has a section on errors, which I quite like.

The following is an excerpt from the JSON-API standard at time of writing.

> An error object MAY have the following members:

>  * `"id"` - A unique identifier for this particular occurrence of the problem.
>  * `"href"` - A URI that MAY yield further details about this particular occurrence of the problem.
>  * `"status"` - The HTTP status code applicable to this problem, expressed as a string value.
>  * `"code"` - An application-specific error code, expressed as a string value.
>  * `"title"` - A short, human-readable summary of the problem. It SHOULD NOT change from occurrence to occurrence of the problem, except for purposes of localization.
>  * `"detail"` - A human-readable explanation specific to this occurrence of the problem.
>  * `"links"` - Associated resources, which can be dereferenced from the request document.
>  * `"path"` - The relative path to the relevant attribute within the associated resource(s). Only appropriate for problems that apply to a single resource or type of resource.

> Additional members MAY be specified within error objects.

When constructing your API error responses, you pretty much just need to make an array with items that looks a bit
like this:

~~~~~~~~
{
  "errors": [{
    "code": "ERR-01234",
    "title": "OAuth Exception",
    "details": "Session has expired at unix time 1385243766. The current unix time is 1385848532.",
    "href": "http://example.org/docs/errors/#ERR-01234"
  }]
}
~~~~~~~~

See how that Facebook example has been slightly tweaked to follow the standard? Nice and easy.

### Problem Details for HTTP APIs

This is currently a [draft RFC], which at the
time of writing was on Draft 7.

The goal of this RFC is to define a "problem detail", like we have been doing throughout this chapter,
but in a standard way (to avoid inventing new formats for each and every HTTP API). It is being headed up
by Mark Nottingham.

Mark wrote a [tutorial about problem details], which will explain the standard a little better.

If you are interested in implementing this standard then there are tools to make it easy:

* [crell/api-problem] for PHP

[draft RFC]: http://tools.ietf.org/html/draft-nottingham-http-problem
[tutorial about Problem Details]: https://www.mnot.net/blog/2013/05/15/http_problem
[crell/api-problem]: https://github.com/Crell/ApiProblem


## Common Pitfalls

### 200 OK and Error Code

If you return an HTTP status code of 200 with an error code, then Chuck Norris will roundhouse your door in, destroy your computer, instantly 35-pass wipe your backups, cancel your Dropbox account, and block you from GitHub. HTTP 4xx or 5xx codes alert the client that something bad happened, and error codes provide specifics of the exact issue if the client is interested.

### Non-Existent, Gone, or Hiding?

404 is drastically overused in APIs. People use it for "never existed", "no longer exists", "you can't view it" and "it is deactivated", which is way too vague. That can be split up into 404, 403 and 410 but this is still vague.

If you get a 403, this could be because the requesting user is not in the correct group to see the requested content. Should the client suggest you upgrade your account somehow? Are you not friends with the user whose content you are trying to view? Should the client suggest you add them as a friend?

A 410 on a resource could be due to a user deleting that entire piece of content, or it could be down to the user deleting their entire account.

In all of these situations, the ideal solution is to complement the HTTP status code with an error code, which can be whatever you want as long as they are unique within your API and documented somewhere.

Do not do what Google does â€” supply a list of error codes while having other error codes that are not documented _anywhere_ â€” because if I see that, I will come for you.

=== FIN



The worst crime you can commit as an API designer is to return errors on a HTTP 200 OK status.


.The folks over at CommitStrip.com know what's up.
image::images/errors-200-ok.jpeg[This monster has got his API responding with HTTP Status 200 OK despite the request failing.]

RFC 7087
JSON API Errors

== GraphQL

[source,javascript]
----
{
  "data": {
    "repository": null
  },
  "errors": [
    {
      "type": "NOT_FOUND",
      "path": [
        "repository"
      ],
      "locations": [
        {
          "line": 7,
          "column": 3
        }
      ],
      "message": "Could not resolve to a Repository with the name 'any'."
    }
  ]
}
----